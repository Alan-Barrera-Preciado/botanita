clc;
clear;
close all;

% ----------------- Parámetros del motor DC 12v -----------------

load('../Estimacion Parametros Fisicos/ParametrosEstimadosMotorIzquierdo.mat')

J_Izq  = p_Izq(1);
b_Izq  = p_Izq(2);
Ka_Izq = p_Izq(3);
Km_Izq = p_Izq(4);
Re_Izq  = p_Izq(5);
L_Izq  = p_Izq(6);

% ----------------- Parámetros del motor DC 24v -----------------

load('../Estimacion Parametros Fisicos/ParametrosEstimadosMotorDerecho.mat')

J_Der  = p_Der(1);
b_Der  = p_Der(2);
Ka_Der = p_Der(3);
Km_Der = p_Der(4);
Re_Der  = p_Der(5);
L_Der  = p_Der(6);

% ----------------- Modelo continuo Izquierda -----------------

A_Izq = [-Re_Izq/L_Izq, -Ka_Izq/L_Izq;
      Km_Izq/J_Izq, -b_Izq/J_Izq];
B_Izq = [1/L_Izq; 0];
C_Izq = [0, 1];  % salida: velocidad
D_Izq = 0;

% ----------------- Modelo continuo Izquierda -----------------

A_Der = [-Re_Der/L_Der, -Ka_Der/L_Der;
      Km_Der/J_Der, -b_Der/J_Der];
B_Der = [1/L_Der; 0];
C_Der = [0, 1];  % salida: velocidad
D_Der = 0;

% ----------------- Discretización -----------------

dt = 0.05;               % Paso de tiempo
S = 10;                  % Tiempo total de simulación
sys_c_Izq = ss(A_Izq, B_Izq, C_Izq, D_Izq);
sys_d_Izq = c2d(sys_c_Izq, dt, 'zoh');

Ad_Izq = sys_d_Izq.A;
Bd_Izq = sys_d_Izq.B;

sys_c_Der = ss(A_Der, B_Der, C_Der, D_Der);
sys_d_Der = c2d(sys_c_Der, dt, 'zoh');

Ad_Der = sys_d_Der.A;
Bd_Der = sys_d_Der.B;

% ----------------- LQR discreto -----------------

Q_Izq = [0.001 0; 0 10];       % Penalización a estados
R_Izq = 100;                  % Penalización al control
[Pd_Izq, ~, ~] = dare(Ad_Izq, Bd_Izq, Q_Izq, R_Izq);
K_Izq = R_Izq \ (Bd_Izq' * Pd_Izq);       % Ganancia óptima discreta
Kr_Izq = inv(C_Izq * inv(eye(2) - Ad_Izq + Bd_Izq*K_Izq) * Bd_Izq);  % Ganancia de referencia

Q_Der = [0.001 0; 0 10];       % Penalización a estados
R_Der = 100;                  % Penalización al control
[Pd_Der, ~, ~] = dare(Ad_Der, Bd_Der, Q_Der, R_Der);
K_Der = R_Der \ (Bd_Der' * Pd_Der);       % Ganancia óptima discreta
Kr_Der = inv(C_Der * inv(eye(2) - Ad_Der + Bd_Der*K_Der) * Bd_Der);  % Ganancia de referencia

% ----------------- Filtro de Kalman discreto -----------------

F_K_Izq = Ad_Izq;
G_K_Izq = Bd_Izq;
H_K_Izq = eye(2);             % Se observan corriente y velocidad
x_Izq_hat = [0; 0];           % Estimación inicial
P_K_Izq = diag([0.01, 0.05]);             % Covarianza inicial

Q_K_Izq = diag([0.00001, 0.000001]);  % Ruido de proceso
R_K_Izq = diag([0.1, 10]); % Ruido de medición

F_K_Der = Ad_Der;
G_K_Der = Bd_Der;
H_K_Der = eye(2);             % Se observan corriente y velocidad
x_Der_hat = [0; 0];           % Estimación inicial
P_K_Der = diag([0.01, 0.05]);             % Covarianza inicial

Q_K_Der = diag([0.00001, 0.000001]);  % Ruido de proceso
R_K_Der = diag([0.1, 10]); % Ruido de medición


% ----------------- Variables iniciales -----------------

x_Izq = [0; 0];     % Estados reales [corriente; velocidad]
u_Izq = 0;          
x_Der = [0; 0];     % Estados reales [corriente; velocidad]
u_Der = 0; 

% ----------------- Almacenamiento para gráficas -----------------

x_Izq_plot = [];
x_Izq_hat_plot = [];
u_Izq_plot = [];
t_plot = [];
ref_Izq_plot = [];
err_Izq_plot = [];

x_Der_plot = [];
x_Der_hat_plot = [];
u_Der_plot = [];
ref_Der_plot = [];
err_Der_plot = [];

% ----------------- Simulación discreta -----------------

for t = 0:dt:S
    
    wr_Izq = 2 + 5*sin(t+1.5);
    wr_Der = 2 - 5*sin(t+1.5);

    z_Izq = H_K_Izq * x_Izq + 0.05*randn(2,1);
    z_Der = H_K_Der * x_Der + 0.05*randn(2,1);

    K_K_Izq = P_K_Izq * H_K_Izq' / (H_K_Izq * P_K_Izq * H_K_Izq' + R_K_Izq);
    x_Izq_hat = x_Izq_hat + K_K_Izq * (z_Izq - H_K_Izq * x_Izq_hat);
    P_K_Izq = (eye(2) - K_K_Izq * H_K_Izq) * P_K_Izq;

    K_K_Der = P_K_Der * H_K_Der' / (H_K_Der * P_K_Der * H_K_Der' + R_K_Der);
    x_Der_hat = x_Der_hat + K_K_Der * (z_Der - H_K_Der * x_Der_hat);
    P_K_Der = (eye(2) - K_K_Der * H_K_Der) * P_K_Der;

    u_Izq = -K_Izq * x_Izq_hat + Kr_Izq * wr_Izq;
    u_Der = -K_Der * x_Der_hat + Kr_Der * wr_Der;

    x_Izq = F_K_Izq * x_Izq + G_K_Izq * u_Izq + 0.01* randn(2,1);
    x_Der = F_K_Der * x_Der + G_K_Der * u_Der + 0.01* randn(2,1);

    x_Izq_hat = F_K_Izq * x_Izq_hat + G_K_Izq * u_Izq;
    P_K_Izq = F_K_Izq * P_K_Izq * F_K_Izq' + Q_K_Izq;

    x_Der_hat = F_K_Der * x_Der_hat + G_K_Der * u_Der;
    P_K_Der = F_K_Der * P_K_Der * F_K_Der' + Q_K_Der;

    x_plot = [x_plot, x];
    xhat_plot = [xhat_plot, x_hat];
    u_plot = [u_plot, u];
    t_plot = [t_plot, t];
    ref_plot = [ref_plot, wr];
    err_plot = [err_plot, wr - x_hat(2)];

    x_plot = [x_plot, x];
    xhat_plot = [xhat_plot, x_hat];
    u_plot = [u_plot, u];
 
    ref_plot = [ref_plot, wr];
    err_plot = [err_plot, wr - x_hat(2)];
end

% ----------------- Gráficas -----------------

figure;
hold on; grid on;
plot(t_plot, x_plot(2,:), 'LineWidth', 2);          % Velocidad real
plot(t_plot, xhat_plot(2,:), 'LineWidth', 2);       % Estimación velocidad
plot(t_plot, ref_plot, 'k--', 'LineWidth', 2);      % Referencia
legend("Velocidad real", "Estimación", "Referencia");
xlabel("Tiempo (s)");
ylabel("Velocidad (rad/s)");
title("Seguimiento de referencia con LQR + Kalman");

figure;
plot(t_plot, u_plot, 'LineWidth', 2);
grid on;
xlabel("Tiempo (s)");
ylabel("Voltaje (V)");
title("Voltaje aplicado");

figure;
plot(t_plot, err_plot, 'LineWidth', 2);
grid on;
xlabel("Tiempo (s)");
ylabel("Error (rad/s)");
title("Error de seguimiento");
